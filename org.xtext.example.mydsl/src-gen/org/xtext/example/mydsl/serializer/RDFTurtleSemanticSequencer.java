/*
 * generated by Xtext 2.33.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.rDFTurtle.Base;
import org.xtext.example.mydsl.rDFTurtle.Blank;
import org.xtext.example.mydsl.rDFTurtle.Collection;
import org.xtext.example.mydsl.rDFTurtle.DatatypeString;
import org.xtext.example.mydsl.rDFTurtle.Directive;
import org.xtext.example.mydsl.rDFTurtle.ItemList;
import org.xtext.example.mydsl.rDFTurtle.LanguageString;
import org.xtext.example.mydsl.rDFTurtle.Literal;
import org.xtext.example.mydsl.rDFTurtle.NodeID;
import org.xtext.example.mydsl.rDFTurtle.ObjectList;
import org.xtext.example.mydsl.rDFTurtle.PredicateObject;
import org.xtext.example.mydsl.rDFTurtle.PredicateObjectList;
import org.xtext.example.mydsl.rDFTurtle.PrefixID;
import org.xtext.example.mydsl.rDFTurtle.Qname;
import org.xtext.example.mydsl.rDFTurtle.RDFTurtlePackage;
import org.xtext.example.mydsl.rDFTurtle.SparqlBase;
import org.xtext.example.mydsl.rDFTurtle.SparqlPrefix;
import org.xtext.example.mydsl.rDFTurtle.Statement;
import org.xtext.example.mydsl.rDFTurtle.Subject;
import org.xtext.example.mydsl.rDFTurtle.Triples;
import org.xtext.example.mydsl.rDFTurtle.TurtleDoc;
import org.xtext.example.mydsl.rDFTurtle.Verb;
import org.xtext.example.mydsl.rDFTurtle.iResource;
import org.xtext.example.mydsl.services.RDFTurtleGrammarAccess;

@SuppressWarnings("all")
public class RDFTurtleSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RDFTurtleGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RDFTurtlePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RDFTurtlePackage.BASE:
				sequence_Base(context, (Base) semanticObject); 
				return; 
			case RDFTurtlePackage.BLANK:
				sequence_Blank(context, (Blank) semanticObject); 
				return; 
			case RDFTurtlePackage.COLLECTION:
				sequence_Collection(context, (Collection) semanticObject); 
				return; 
			case RDFTurtlePackage.DATATYPE_STRING:
				sequence_DatatypeString(context, (DatatypeString) semanticObject); 
				return; 
			case RDFTurtlePackage.DIRECTIVE:
				sequence_Directive(context, (Directive) semanticObject); 
				return; 
			case RDFTurtlePackage.ITEM_LIST:
				sequence_ItemList(context, (ItemList) semanticObject); 
				return; 
			case RDFTurtlePackage.LANGUAGE_STRING:
				sequence_LanguageString(context, (LanguageString) semanticObject); 
				return; 
			case RDFTurtlePackage.LITERAL:
				sequence_Literal(context, (Literal) semanticObject); 
				return; 
			case RDFTurtlePackage.NODE_ID:
				sequence_NodeID(context, (NodeID) semanticObject); 
				return; 
			case RDFTurtlePackage.OBJECT:
				sequence_Object(context, (org.xtext.example.mydsl.rDFTurtle.Object) semanticObject); 
				return; 
			case RDFTurtlePackage.OBJECT_LIST:
				sequence_ObjectList(context, (ObjectList) semanticObject); 
				return; 
			case RDFTurtlePackage.PREDICATE_OBJECT:
				sequence_PredicateObject(context, (PredicateObject) semanticObject); 
				return; 
			case RDFTurtlePackage.PREDICATE_OBJECT_LIST:
				sequence_PredicateObjectList(context, (PredicateObjectList) semanticObject); 
				return; 
			case RDFTurtlePackage.PREFIX_ID:
				sequence_PrefixID(context, (PrefixID) semanticObject); 
				return; 
			case RDFTurtlePackage.QNAME:
				sequence_Qname(context, (Qname) semanticObject); 
				return; 
			case RDFTurtlePackage.SPARQL_BASE:
				sequence_SparqlBase(context, (SparqlBase) semanticObject); 
				return; 
			case RDFTurtlePackage.SPARQL_PREFIX:
				sequence_SparqlPrefix(context, (SparqlPrefix) semanticObject); 
				return; 
			case RDFTurtlePackage.STATEMENT:
				sequence_Statement(context, (Statement) semanticObject); 
				return; 
			case RDFTurtlePackage.SUBJECT:
				sequence_Subject(context, (Subject) semanticObject); 
				return; 
			case RDFTurtlePackage.TRIPLES:
				sequence_Triples(context, (Triples) semanticObject); 
				return; 
			case RDFTurtlePackage.TURTLE_DOC:
				sequence_TurtleDoc(context, (TurtleDoc) semanticObject); 
				return; 
			case RDFTurtlePackage.VERB:
				sequence_Verb(context, (Verb) semanticObject); 
				return; 
			case RDFTurtlePackage.IRESOURCE:
				if (rule == grammarAccess.getPredicateRule()) {
					sequence_Predicate(context, (iResource) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIResourceRule()) {
					sequence_iResource(context, (iResource) semanticObject); 
					return; 
				}
				else break;
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Base returns Base
	 *
	 * Constraint:
	 *     iriref=IRIREF
	 * </pre>
	 */
	protected void sequence_Base(ISerializationContext context, Base semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RDFTurtlePackage.Literals.BASE__IRIREF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RDFTurtlePackage.Literals.BASE__IRIREF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBaseAccess().getIrirefIRIREFTerminalRuleCall_1_0(), semanticObject.getIriref());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Blank returns Blank
	 *
	 * Constraint:
	 *     (nodeID=NodeID | isSquare?='[]' | predicateObjectList=PredicateObjectList | collection=Collection)
	 * </pre>
	 */
	protected void sequence_Blank(ISerializationContext context, Blank semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Collection returns Collection
	 *
	 * Constraint:
	 *     itemList=ItemList?
	 * </pre>
	 */
	protected void sequence_Collection(ISerializationContext context, Collection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DatatypeString returns DatatypeString
	 *
	 * Constraint:
	 *     (qutoedString=QuotedString resource=iResource)
	 * </pre>
	 */
	protected void sequence_DatatypeString(ISerializationContext context, DatatypeString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RDFTurtlePackage.Literals.DATATYPE_STRING__QUTOED_STRING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RDFTurtlePackage.Literals.DATATYPE_STRING__QUTOED_STRING));
			if (transientValues.isValueTransient(semanticObject, RDFTurtlePackage.Literals.DATATYPE_STRING__RESOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RDFTurtlePackage.Literals.DATATYPE_STRING__RESOURCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDatatypeStringAccess().getQutoedStringQuotedStringParserRuleCall_0_0(), semanticObject.getQutoedString());
		feeder.accept(grammarAccess.getDatatypeStringAccess().getResourceIResourceParserRuleCall_2_0(), semanticObject.getResource());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Directive returns Directive
	 *
	 * Constraint:
	 *     (prefix=PrefixID | base=Base | sparqlPrefix=SparqlPrefix | sparqlBase=SparqlBase)
	 * </pre>
	 */
	protected void sequence_Directive(ISerializationContext context, Directive semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ItemList returns ItemList
	 *
	 * Constraint:
	 *     (objects+=Object objects+=Object*)
	 * </pre>
	 */
	protected void sequence_ItemList(ISerializationContext context, ItemList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LanguageString returns LanguageString
	 *
	 * Constraint:
	 *     (qutoedString=QuotedString lang=ID?)
	 * </pre>
	 */
	protected void sequence_LanguageString(ISerializationContext context, LanguageString semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Literal returns Literal
	 *
	 * Constraint:
	 *     (
	 *         languageString=LanguageString | 
	 *         datatypeString=DatatypeString | 
	 *         dword=INT | 
	 *         real=DOUBLE | 
	 *         decimal=DECIMAL | 
	 *         bool=Boolean
	 *     )
	 * </pre>
	 */
	protected void sequence_Literal(ISerializationContext context, Literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NodeID returns NodeID
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_NodeID(ISerializationContext context, NodeID semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RDFTurtlePackage.Literals.NODE_ID__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RDFTurtlePackage.Literals.NODE_ID__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNodeIDAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ObjectList returns ObjectList
	 *
	 * Constraint:
	 *     (objects+=Object objects+=Object*)
	 * </pre>
	 */
	protected void sequence_ObjectList(ISerializationContext context, ObjectList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Object returns Object
	 *
	 * Constraint:
	 *     (resource=iResource | blank=Blank | literal=Literal)
	 * </pre>
	 */
	protected void sequence_Object(ISerializationContext context, org.xtext.example.mydsl.rDFTurtle.Object semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PredicateObjectList returns PredicateObjectList
	 *
	 * Constraint:
	 *     (predicateObjects+=PredicateObject predicateObjects+=PredicateObject*)
	 * </pre>
	 */
	protected void sequence_PredicateObjectList(ISerializationContext context, PredicateObjectList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PredicateObject returns PredicateObject
	 *
	 * Constraint:
	 *     (verb=Verb objectList=ObjectList)
	 * </pre>
	 */
	protected void sequence_PredicateObject(ISerializationContext context, PredicateObject semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RDFTurtlePackage.Literals.PREDICATE_OBJECT__VERB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RDFTurtlePackage.Literals.PREDICATE_OBJECT__VERB));
			if (transientValues.isValueTransient(semanticObject, RDFTurtlePackage.Literals.PREDICATE_OBJECT__OBJECT_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RDFTurtlePackage.Literals.PREDICATE_OBJECT__OBJECT_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPredicateObjectAccess().getVerbVerbParserRuleCall_0_0(), semanticObject.getVerb());
		feeder.accept(grammarAccess.getPredicateObjectAccess().getObjectListObjectListParserRuleCall_1_0(), semanticObject.getObjectList());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Predicate returns iResource
	 *
	 * Constraint:
	 *     ir=iResource
	 * </pre>
	 */
	protected void sequence_Predicate(ISerializationContext context, iResource semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RDFTurtlePackage.Literals.IRESOURCE__IR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RDFTurtlePackage.Literals.IRESOURCE__IR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPredicateAccess().getIrIResourceParserRuleCall_0(), semanticObject.getIr());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PrefixID returns PrefixID
	 *
	 * Constraint:
	 *     (prefixName=PrefixName iriref=IRIREF)
	 * </pre>
	 */
	protected void sequence_PrefixID(ISerializationContext context, PrefixID semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RDFTurtlePackage.Literals.PREFIX_ID__PREFIX_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RDFTurtlePackage.Literals.PREFIX_ID__PREFIX_NAME));
			if (transientValues.isValueTransient(semanticObject, RDFTurtlePackage.Literals.PREFIX_ID__IRIREF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RDFTurtlePackage.Literals.PREFIX_ID__IRIREF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrefixIDAccess().getPrefixNamePrefixNameParserRuleCall_1_0(), semanticObject.getPrefixName());
		feeder.accept(grammarAccess.getPrefixIDAccess().getIrirefIRIREFTerminalRuleCall_2_0(), semanticObject.getIriref());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Qname returns Qname
	 *
	 * Constraint:
	 *     (prefixName=PrefixName name=ID?)
	 * </pre>
	 */
	protected void sequence_Qname(ISerializationContext context, Qname semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SparqlBase returns SparqlBase
	 *
	 * Constraint:
	 *     iriref=IRIREF
	 * </pre>
	 */
	protected void sequence_SparqlBase(ISerializationContext context, SparqlBase semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RDFTurtlePackage.Literals.SPARQL_BASE__IRIREF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RDFTurtlePackage.Literals.SPARQL_BASE__IRIREF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSparqlBaseAccess().getIrirefIRIREFTerminalRuleCall_1_0(), semanticObject.getIriref());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SparqlPrefix returns SparqlPrefix
	 *
	 * Constraint:
	 *     (prefixName=PrefixName iriref=IRIREF)
	 * </pre>
	 */
	protected void sequence_SparqlPrefix(ISerializationContext context, SparqlPrefix semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RDFTurtlePackage.Literals.SPARQL_PREFIX__PREFIX_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RDFTurtlePackage.Literals.SPARQL_PREFIX__PREFIX_NAME));
			if (transientValues.isValueTransient(semanticObject, RDFTurtlePackage.Literals.SPARQL_PREFIX__IRIREF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RDFTurtlePackage.Literals.SPARQL_PREFIX__IRIREF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSparqlPrefixAccess().getPrefixNamePrefixNameParserRuleCall_1_0(), semanticObject.getPrefixName());
		feeder.accept(grammarAccess.getSparqlPrefixAccess().getIrirefIRIREFTerminalRuleCall_2_0(), semanticObject.getIriref());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Statement
	 *
	 * Constraint:
	 *     (directive=Directive | triples=Triples)
	 * </pre>
	 */
	protected void sequence_Statement(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Subject returns Subject
	 *
	 * Constraint:
	 *     (resource=iResource | blank=Blank)
	 * </pre>
	 */
	protected void sequence_Subject(ISerializationContext context, Subject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Triples returns Triples
	 *
	 * Constraint:
	 *     (subject=Subject predicateObjectList=PredicateObjectList)
	 * </pre>
	 */
	protected void sequence_Triples(ISerializationContext context, Triples semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RDFTurtlePackage.Literals.TRIPLES__SUBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RDFTurtlePackage.Literals.TRIPLES__SUBJECT));
			if (transientValues.isValueTransient(semanticObject, RDFTurtlePackage.Literals.TRIPLES__PREDICATE_OBJECT_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RDFTurtlePackage.Literals.TRIPLES__PREDICATE_OBJECT_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTriplesAccess().getSubjectSubjectParserRuleCall_0_0(), semanticObject.getSubject());
		feeder.accept(grammarAccess.getTriplesAccess().getPredicateObjectListPredicateObjectListParserRuleCall_1_0(), semanticObject.getPredicateObjectList());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TurtleDoc returns TurtleDoc
	 *
	 * Constraint:
	 *     statements+=Statement+
	 * </pre>
	 */
	protected void sequence_TurtleDoc(ISerializationContext context, TurtleDoc semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Verb returns Verb
	 *
	 * Constraint:
	 *     (predicate=Predicate | isA?='a')
	 * </pre>
	 */
	protected void sequence_Verb(ISerializationContext context, Verb semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     iResource returns iResource
	 *
	 * Constraint:
	 *     (iriRef=IRIREF | qname=Qname)
	 * </pre>
	 */
	protected void sequence_iResource(ISerializationContext context, iResource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
